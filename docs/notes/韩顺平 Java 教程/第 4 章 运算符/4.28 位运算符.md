---
title: 28 位运算符
createTime: 2024/12/01 21:32:00
permalink: /hsp-java/4-28-bitwise-operators/
---

Java 中有 7 个位运算：`&` `|` `^` `~` `>>` `<<` `>>>` 。

1. **按位与 (****`&`****)：**
	- 运算规则：只有两个操作数的对应位都为 1，结果才为 1，否则为 0。
	- 示例：`5 & 3 = 1`  。考虑 `int` 型变量，过程如下：

		| 十进制       | 32 位二进制                             |
		| --------- | ----------------------------------- |
		| 5         | 00000000 00000000 00000000 00000101 |
		| 3         | 00000000 00000000 00000000 00000011 |
		| 5 & 3 = 1 | 00000000 00000000 00000000 00000001 |

2. **按位或 (****`|`****)：**
	- 运算规则：只要两个操作数的对应位有一个为 1，结果就为 1。
	- 示例：`5 | 3 = 7` 。考虑 `int` 型变量，过程如下：

		| 十进制       | 32 位二进制                             |
		| --------- | ----------------------------------- |
		| 5         | 00000000 00000000 00000000 00000101 |
		| 3         | 00000000 00000000 00000000 00000011 |
		| 5 | 3 = 7 | 00000000 00000000 00000000 00000111 |

3. **按位异或 (****`^`****)：**
	- 运算规则：两个操作数的对应位不同时，结果为 1；相同则为 0。
	- 示例：`5 ^ 3 = 6` 。考虑 `int` 型变量，过程如下：

		| 十进制       | 32 位二进制                             |
		| --------- | ----------------------------------- |
		| 5         | 00000000 00000000 00000000 00000101 |
		| 3         | 00000000 00000000 00000000 00000011 |
		| 5 ^ 3 = 6 | 00000000 00000000 00000000 00000110 |

4. **按位非 (****`~`****)：**
	- 运算规则：将操作数的每一位取反，即 1 变 0，0 变 1。
	- 示例：`~ 5 = -6`  。考虑 `int` 型变量，过程如下：

		| 十进制 | 32 位二进制                             |
		| --- | ----------------------------------- |
		| 5   | 00000000 00000000 00000000 00000101 |
		| ~5  | 11111111 11111111 11111111 11111010 |


		由于计算机对于整数实际上是使用 2 的补码 (Two's Complement) 来运算。因此为得到 `~5`  的十进制数，我们需要计算其原码：

    	1. 补码减一得到反码；
    	2. 将反码转为原码（除符号位按位取反）。

    	| 编码  | 值                                   |
    	| --- | ----------------------------------- |
    	| 补码  | 11111111 11111111 11111111 11111010 |
    	| 反码  | 11111111 11111111 11111111 11111001 |
    	| 原码  | 10000000 00000000 00000000 00000110 |
    	| 十进制 | -6                                  |

5. **有符号右移 (****`>>`****)：**
	- 运算规则：将操作数的二进制位向右移动指定的位数，左边空出的位用符号位填充。
	- 示例：
		- `5 >> 1 = 2` 。

			| 十进制    | 32 位二进制                             |
			| ------ | ----------------------------------- |
			| 5      | 00000000 00000000 00000000 00000101 |
			| 5 >> 1 | 00000000 00000000 00000000 00000010 |

		- `-5 >> 1 = -3` 。

			| 十进制     | 32 位二进制                             | 编码 |
			| ------- | ----------------------------------- | -- |
			| -5      | 10000000 00000000 00000000 00000101 | 原码 |
			| -5      | 11111111 11111111 11111111 11111010 | 反码 |
			| -5      | 11111111 11111111 11111111 11111011 | 补码 |
			| -5 >> 1 | 111111111 11111111 11111111 1111101 | 补码 |
			| -5 >> 1 | 111111111 11111111 11111111 1111100 | 反码 |
			| -3      | 10000000 00000000 00000000 00000011 | 原码 |

6. **左移 (****`<<`****)：**
	- 运算规则：将操作数的二进制位向左移动指定的位数，右边空出的位用 0 填充。
	- 示例：`5 << 1 = 10` 。

		| 十进制    | 32 位二进制                             |
		| ------ | ----------------------------------- |
		| 5      | 00000000 00000000 00000000 00000101 |
		| 5 << 1 | 00000000 00000000 00000000 00001010 |

7. **无符号右移 (****`>>>`****)：**
	- 运算规则：类似于有符号右移，但无论正负，左边空出的位都用 0 填充。
	- 示例：
		- `5 >>> 1 = 2`  。

			| 十进制     | 32 位二进制                             |
			| ------- | ----------------------------------- |
			| 5       | 00000000 00000000 00000000 00000101 |
			| 5 >>> 1 | 00000000 00000000 00000000 00000010 |

		- `-5 >>> 1 = 2147483645` 。

			| 十进制        | 32 位二进制                             | 编码 |
			| ---------- | ----------------------------------- | -- |
			| -5         | 10000000 00000000 00000000 00000101 | 原码 |
			| -5         | 11111111 11111111 11111111 11111010 | 反码 |
			| -5         | 11111111 11111111 11111111 11111011 | 补码 |
			| -5 >>> 1   | 011111111 11111111 11111111 1111101 | 补码 |
			| 2147483645 | 011111111 11111111 11111111 1111101 | 原码 |


> ⚠️ 特别说明：没有 `<<<` 符号。

