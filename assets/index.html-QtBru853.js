import{_ as d,c as e,d as a,o}from"./app-B6dbd404.js";const r={};function i(c,t){return o(),e("div",null,t[0]||(t[0]=[a("<p>算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。常用运算符如下表所示：</p><table><thead><tr><th>运算符</th><th>运算</th><th>运算</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+7</td><td>7</td></tr><tr><td>-</td><td>负号</td><td>-7</td><td>-7</td></tr><tr><td>*</td><td>乘法</td><td>9*8</td><td>72</td></tr><tr><td>/</td><td>除法</td><td>9/2</td><td>4.5</td></tr><tr><td>%</td><td>取模</td><td>9%2</td><td>1</td></tr><tr><td>++</td><td>自增 (前)：先运算后取值</td><td>a=2;b=++a;</td><td>a=3;b=3</td></tr><tr><td>++</td><td>自增 (后)：先取值后运算</td><td>a=2;b=a++;</td><td>a=3;b=2</td></tr><tr><td>--</td><td>自减 (前)：先运算后取值</td><td>a=2;b=--a;</td><td>a=1;b=1</td></tr><tr><td>--</td><td>自减 (后)：先取值后运算</td><td>a=2;b=a--;</td><td>a=1;b=2</td></tr><tr><td>+</td><td>字符串相加</td><td>&quot;hsp&quot; + &quot;edu&quot;</td><td>&quot;hsp edu&quot;</td></tr></tbody></table><p>一些需要注意的细节如下：</p><ol><li>对于除号 <code>/</code>，它的整数除和小数除是有区别的：整数之间做除法时，只保留整 数部分而舍弃小数部分。例如：<code>int x=10/3</code> ，结果是 <code>3</code> 。</li><li><code>a % b</code> 等价于 <code>a - a / b * b</code> ， 这样我们可以看到取模的一个本质运算。</li><li>当自增当做一个独立语言使用时，不管是 <code>++i;</code> 还是 <code>i++;</code> 都是一样的。</li><li>自增当做一个表达式使用时， <code>j = ++i</code> 等价于 <code>j = i; i = i + 1;</code> 。</li><li>当自增当做一个表达式使用时 <code>j= i++</code> 等价 <code>i = i + 1; j = i;</code> 。</li></ol>",4)]))}const m=d(r,[["render",i],["__file","index.html.vue"]]),l=JSON.parse('{"path":"/hsp-java/4-2-arithmetic-operators/","title":"2 算术运算符","lang":"zh-CN","frontmatter":{"title":"2 算术运算符","createTime":"2024/11/29 19:59:00","permalink":"/hsp-java/4-2-arithmetic-operators/"},"headers":[],"readingTime":{"minutes":1.1,"words":330},"git":{"updatedTime":1740991950000,"contributors":[{"name":"dead_summer","username":"dead_summer","email":"2941325451@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/dead_summer?v=4","url":"https://github.com/dead_summer"}]},"filePathRelative":"notes/韩顺平 Java 教程/第 4 章 运算符/4.02 算术运算符.md"}');export{m as comp,l as data};
