import{_ as a,c as n,d as p,o as t}from"./app-B6dbd404.js";const e={};function m(l,s){return t(),n("div",null,s[0]||(s[0]=[p('<h3 id="机器数和真值" tabindex="-1"><a class="header-anchor" href="#机器数和真值"><span><strong>机器数和真值</strong></span></a></h3><p>在学习原码，反码和补码之前，需要先了解机器数和真值的概念。</p><h4 id="机器数" tabindex="-1"><a class="header-anchor" href="#机器数"><span><strong>机器数</strong></span></a></h4><p>一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为 0, 负数为 1.</p><p>比如，十进制中的数 +3 ，计算机字节长为 8 位，转换成二进制就是 00000011 。如果是 -3 ，就是 10000011 。</p><p>那么，这里的 00000011 和 10000011 就是机器数。</p><h4 id="真值" tabindex="-1"><a class="header-anchor" href="#真值"><span><strong>真值</strong></span></a></h4><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001 的真值为 +000 0001 = +1，1000 0001 的真值为 –000 0001 = –1</p><h3 id="原码-反码-补码" tabindex="-1"><a class="header-anchor" href="#原码-反码-补码"><span><strong>原码，反码，补码</strong></span></a></h3><p>在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式。</p><h4 id="原码" tabindex="-1"><a class="header-anchor" href="#原码"><span><strong>原码</strong></span></a></h4><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。</p><p>比如如果是 8 位二进制：+1 的原码为 0000 0001 ，-1 的原码为 1000 0001 ，其中第一位是符号位。因此 8 位二进制数的取值范围就是：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">[</mo><mn>11111111</mn><mo separator="true">,</mo><mn>01111111</mn><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mo>−</mo><mn>127</mn><mo separator="true">,</mo><mn>127</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">[1111 1111 , 0111 1111] = [-127 , 127] . </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">11111111</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">01111111</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">127</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">127</span><span class="mclose">]</span><span class="mord">.</span></span></span></span></span></p><p>原码是人脑最容易理解和计算的表示方式。</p><h4 id="反码" tabindex="-1"><a class="header-anchor" href="#反码"><span><strong>反码</strong></span></a></h4><p>反码的表示方法是：</p><ul><li>正数的反码是其本身；</li><li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</li></ul><p>如：+1 的原码是 00000001 ，则其反码为 00000001 。-1 的原码是 10000001 ，则其反码为 11111110 。</p><p>可见如果一个反码表示的是负数，我们无法直观看出来它的数值，通常需将其转换成原码再计算。</p><h4 id="补码" tabindex="-1"><a class="header-anchor" href="#补码"><span><strong>补码</strong></span></a></h4><p>补码的表示方法是：</p><ul><li>正数的补码就是其本身；</li><li>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1 。（即在反码的基础上+1）。</li></ul><p>如 +1 的原码：00000001，反码： 00000001 ，补码：00000001 。-1 的原码：10000001 ，补码：11111110 ，反码： 11111111 。</p><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p><h3 id="为何要使用原码-反码和补码" tabindex="-1"><a class="header-anchor" href="#为何要使用原码-反码和补码"><span><strong>为何要使用原码, 反码和补码</strong></span></a></h3><p>现在我们知道了计算机可以有三种编码方式表示一个数。对于正数，其三种编码方式的结果都相同。但是对于负数，如 -1 的原码：10000001 ，补码：11111110 ，反码： 11111111 完全不同。可以归纳对于任意负数，其原码，反码和补码均是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？</p><p>首先，因为人脑可以知道第一位是符号位。在计算的时候我们可以根据符号位，从而对真值区域进行加减。但是对于计算机，加减乘数是最基础的运算，应尽量设计简单.。迫使计算机辨别符号位，显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。根据运算法则，减去一个正数等于加上一个负数，即： 1 - 1 = 1 + (-1) = 0 ，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>于是人们开始探索，将符号位参与运算，并且只保留加法的方法。首先来看原码：</p><p>计算十进制的表达式：1 - 1 = 0 :</p><blockquote><p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p></blockquote><p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</p><p>为了解决原码做减法的问题，出现了反码：</p><p>计算十进制的表达式：1 - 1 = 0 :</p><blockquote><p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p></blockquote><p>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在 0 这个特殊的数值上。虽然在数学中+0 和 -0 是一样的，但是 0 带符号是没有任何意义的，而且会有 [0000 0000]原 和[1000 0000]原 两个编码表示 0 。</p><p>于是补码的出现，解决了0 的符号以及两个编码的问题：</p><blockquote><p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原</p></blockquote><p>这样 0 用 [0000 0000]补 表示，不会出现 -0 。因此即可用 [1000 0000]补 表示 -128 :</p><blockquote><p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p></blockquote><p>1-127 的结果应该是 -128，在用补码运算的结果中，[1000 0000]补 就是-128。但是注意因为实际上是使用以前的 -0 的补码来表示 -128，所以我们不考虑 -128 的原码和反码。</p><p>使用补码，不仅仅修复了 0 的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么 8 位二进制，使用原码或反码表示的范围为 [-127，+127]，而使用补码表示的范围为 [-128，127]。</p><p>因为机器使用补码，所以对于编程中常用到的 32 位 <code>int</code> 类型，可以表示范围是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mtext>，</mtext><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{31}，2^{31}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值。</p>',44)]))}const o=a(e,[["render",m],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/hsp-java/4-27-original-code-complement-code-2s-complement/","title":"27 原码、反码、补码","lang":"zh-CN","frontmatter":{"title":"27 原码、反码、补码","createTime":"2024/12/01 20:43:00","permalink":"/hsp-java/4-27-original-code-complement-code-2s-complement/"},"headers":[],"readingTime":{"minutes":5.14,"words":1543},"git":{"updatedTime":1740991950000,"contributors":[{"name":"dead_summer","username":"dead_summer","email":"2941325451@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/dead_summer?v=4","url":"https://github.com/dead_summer"}]},"filePathRelative":"notes/韩顺平 Java 教程/第 4 章 运算符/4.27 原码、反码、补码.md"}');export{o as comp,r as data};
